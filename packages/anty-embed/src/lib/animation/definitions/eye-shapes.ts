/**
 * Eye Shape Definitions
 *
 * All shapes are stored as "left eye" versions (point 0 on left edge).
 * Right eye shapes are generated by mirroring X coordinates.
 *
 * This ensures smooth morphing where points never cross over:
 * - Left eye: point 0 stays on left edge during all morphs
 * - Right eye: point 0 stays on right edge during all morphs
 *
 * All paths use M, C, C, V, C, C, L structure for smooth morphing.
 */

/**
 * Mirror an SVG path horizontally around the center.
 * Transforms all X coordinates: newX = width - oldX
 *
 * This creates a "right eye" version where:
 * - The visual shape is the same (mirrored)
 * - Point indices stay on their respective sides
 * - Morphing between shapes keeps points stable
 */
export function mirrorSvgPath(pathData: string, width: number): string {
  // Regex to match SVG path commands and their parameters
  // Handles: M, L, C, S, Q, T, H, V, Z (and lowercase versions)
  const commandRegex = /([MLCSQTHVZmlcsqthvz])([^MLCSQTHVZmlcsqthvz]*)/g;

  let result = '';
  let match;

  while ((match = commandRegex.exec(pathData)) !== null) {
    const command = match[1];
    const params = match[2].trim();

    // Parse numbers from parameters
    const numbers = params.match(/-?[\d.]+(?:e[+-]?\d+)?/gi)?.map(Number) || [];

    switch (command.toUpperCase()) {
      case 'M': // moveto: x, y
      case 'L': // lineto: x, y
      case 'T': // smooth quadratic: x, y
        if (numbers.length >= 2) {
          numbers[0] = width - numbers[0]; // Mirror X
        }
        break;

      case 'H': // horizontal line: x
        if (numbers.length >= 1) {
          numbers[0] = width - numbers[0]; // Mirror X
        }
        break;

      case 'V': // vertical line: y - no X to mirror
        break;

      case 'C': // cubic bezier: x1, y1, x2, y2, x, y
        if (numbers.length >= 6) {
          numbers[0] = width - numbers[0]; // Mirror x1
          numbers[2] = width - numbers[2]; // Mirror x2
          numbers[4] = width - numbers[4]; // Mirror x
        }
        break;

      case 'S': // smooth cubic: x2, y2, x, y
      case 'Q': // quadratic: x1, y1, x, y
        if (numbers.length >= 4) {
          numbers[0] = width - numbers[0]; // Mirror x1/x2
          numbers[2] = width - numbers[2]; // Mirror x
        }
        break;

      case 'Z': // closepath - no parameters
        break;
    }

    // Reconstruct the command with mirrored coordinates
    result += command + numbers.join(' ');
  }

  return result;
}

// Cache for mirrored paths (computed once per shape)
const mirroredPathCache = new Map<string, string>();

/**
 * Get the appropriate eye shape path for a given side.
 *
 * @param shapeName - The base shape name (e.g., 'IDLE', 'ANGRY')
 * @param side - Which eye ('left' uses base path, 'right' uses mirrored path)
 * @returns The SVG path data for that eye
 */
export function getEyeShape(shapeName: EyeShapeName, side: 'left' | 'right'): string {
  // Special case: OFF shapes are already side-specific
  if (shapeName === 'OFF_LEFT') {
    return EYE_SHAPES.OFF_LEFT;
  }
  if (shapeName === 'OFF_RIGHT') {
    return EYE_SHAPES.OFF_RIGHT;
  }

  const basePath = EYE_SHAPES[shapeName];

  if (side === 'left') {
    return basePath;
  }

  // For right eye, return mirrored path (cached)
  const cacheKey = `${shapeName}_right`;
  if (!mirroredPathCache.has(cacheKey)) {
    const dimensions = EYE_DIMENSIONS[shapeName];
    mirroredPathCache.set(cacheKey, mirrorSvgPath(basePath, dimensions.width));
  }

  return mirroredPathCache.get(cacheKey)!;
}

/**
 * Get dimensions for an eye shape (same for both sides)
 */
export function getEyeDimensions(shapeName: EyeShapeName): { width: number; height: number; viewBox: string } {
  // Special case: OFF shapes
  if (shapeName === 'OFF_LEFT') {
    return EYE_DIMENSIONS.OFF_LEFT;
  }
  if (shapeName === 'OFF_RIGHT') {
    return EYE_DIMENSIONS.OFF_RIGHT;
  }

  return EYE_DIMENSIONS[shapeName];
}

// Base eye shapes (LEFT eye versions - point 0 on left edge)
export const EYE_SHAPES = {
  // IDLE - Default tall pill shape (20×45)
  // Base shape that all other eyes morph from/to
  IDLE: "M1.00146e-10 35.5C-2.44505e-05 40.7467 4.47719 45 10.0001 45C15.5229 44.9999 20 40.7467 20 35.5V9.4999C20 4.25325 15.5229 0 10.0001 0C4.47727 0 0.000145614 4.25325 0.000121164 9.49992L1.00146e-10 35.5Z",

  // HAPPY - Shorter with smile curve at bottom (24×29)
  // Same structure as IDLE, bottom curves upward for smile
  HAPPY: "M0 29C0 29 5.37252 26.041 12 26.041C18.62736 26.041 24 29 24 29V11.2406C24 5.0345 18.62748 0 12.00012 0C5.37272 0 0.000175 5.0345 0.000145 11.2407L0 29Z",

  // LOOK - Wider, shorter pill for looking left/right (23×28)
  // Will be positioned left or right in container
  LOOK: "M1.15167e-10 17.36C-2.81181e-05 23.2363 5.14877 28.0001 11.5001 28C17.8513 27.9999 23 23.2363 23 17.36V10.6399C23 4.76364 17.8513 0 11.5001 0C5.14886 0 0.000167456 4.76364 0.000139339 10.6399L1.15167e-10 17.36Z",

  // HALF - Half-height eye with flat bottom (22×28)
  // Used for wink (one eye open, one half)
  HALF: "M0 28C0 28 4.925 28 11 28C17.075 28 22 28 22 28V10.857C22 4.861 17.075 0 11 0C4.925 0 0.00016 4.861 0.00013 10.857L0 28Z",

  // CLOSED - Thin horizontal line for closed eyes (23×8)
  // Used for blink and wink
  CLOSED: "M1.15e-10 4.493C-2.81e-05 6.995 5.14877 6.679 11.5001 6.679C17.8513 6.679 23 6.995 23 4.493V2.199C23 -0.302 17.8513 0.0128 11.5001 0.0128C5.14886 0.0128 0.000167 -0.302 0.000139 2.199L1.15e-10 4.493Z",

  // ANGRY - Flat top, curved bottom for angry brows (36×18)
  // Rotated 20deg in animation for left eye, flipped+rotated for right
  ANGRY: "M1.8e-10 2.147C-4.4e-05 9.482 8.058 18 18 18C27.95 18 36 9.482 36 2.147V0C36 0 27.95 3.857 18 3.857C8.058 3.857 0.000225 2.5e-05 0.000225 2.5e-05L1.8e-10 2.147Z",

  // SAD - Flat top, curved droopy bottom (27×14)
  // Rotated -15deg in animation for left eye, flipped+rotated for right
  SAD: "M1e-10 1.613C-2.9e-05 7.122 6.045 14 13.5 14C20.96 14 27 7.122 27 1.613V0C27 0 20.96 2.897 13.5 2.897C6.045 2.897 0.00014 1.9e-05 0.00014 1.9e-05L1e-10 1.613Z",

  // OFF/LOGO shapes - Triangular arrow shapes for OFF state (26x45 viewBox)
  // LEFT eye points RIGHT (>) toward center
  // RIGHT eye points LEFT (<) toward center
  // These are stored pre-computed to ensure instant snapping without morphing
  OFF_LEFT: "M0.119717 3.2515C0.128897 0.356275 3.62969 -1.08732 5.67695 0.959904L24.4925 19.7752C25.7639 21.0465 25.7639 23.1077 24.4926 24.379L5.55727 43.3143C3.50298 45.3686 -0.00919365 43.9073 1.80842e-05 41.0021L0.119717 3.2515Z",
  OFF_RIGHT: "M25.8803 3.2515C25.8711 0.356275 22.3703 -1.08732 20.323 0.959904L1.5075 19.7752C0.2361 21.0465 0.2361 23.1077 1.5074 24.379L20.4427 43.3143C22.497 45.3686 26.0092 43.9073 26 41.0021L25.8803 3.2515Z",
} as const;

export const EYE_DIMENSIONS = {
  IDLE: {
    width: 20,
    height: 45,
    viewBox: "0 0 20 45",
  },
  HAPPY: {
    width: 24,
    height: 29,
    viewBox: "0 0 24 29",
  },
  LOOK: {
    width: 23,
    height: 28,
    viewBox: "0 0 23 28",
  },
  HALF: {
    width: 22,
    height: 28,
    viewBox: "0 0 22 28",
  },
  CLOSED: {
    width: 23,
    height: 8,
    viewBox: "0 0 23 8",
  },
  ANGRY: {
    width: 36,
    height: 18,
    viewBox: "0 0 36 18",
  },
  SAD: {
    width: 27,
    height: 14,
    viewBox: "0 0 27 14",
  },
  OFF_LEFT: {
    width: 26,
    height: 45,
    viewBox: "0 0 26 45",
  },
  OFF_RIGHT: {
    width: 26,
    height: 45,
    viewBox: "0 0 26 45",
  },
} as const;

export type EyeShapeName = keyof typeof EYE_SHAPES;
